/**
 * @file PolynomialFit.hpp
 * @author bwu
 * @brief polynomial fit
 * @version 0.1
 * @date 2023-07-14
 */
#pragma once
#include <boost/numeric/ublas/matrix.hpp>
#include <boost/numeric/ublas/lu.hpp>
#include "generic/common/Exception.hpp"

namespace generic::math {

/**
 * @brief Finds the coefficients of a polynomial p(x) of degree n that fits the data, 
 * p(x(i)) to y(i), in a least squares sense. The result p is a row vector of
 * length n+1 containing the polynomial coefficients in incremental powers.
 * @tparam RandomAccessContainer random access container concept
 * @param xValues x axis values
 * @param yValues y axis values
 * @param degree polynomial degree including the constant
 * @param weights optional, weights to apply to the y-coordinates of the sample points
 * @return std::vector<Scalar> coefficients of a polynomial starting at the constant coefficient and ending with the coefficient of power to degree.
 */
template <typename RandomAccessContainer, std::enable_if_t<std::is_floating_point_v<typename RandomAccessContainer::value_type>, bool> = true>
inline std::vector<typename RandomAccessContainer::value_type> PolyFit(const RandomAccessContainer & xValues, const RandomAccessContainer & yValues, const int degree, const RandomAccessContainer & weights = {})
{    
    if (xValues.size() != yValues.size())
       ThrowException("X and Y sizes do not match");
    
    bool useWeights = not weights.empty();
    if (useWeights && weights.size() != xValues.size())
       ThrowException("Weights and X,Y sizes do not match");
    
    // one more because of c0 coefficient
    size_t nCount = xValues.size();
    size_t numCoefficients = degree + 1;
    using Scalar = typename RandomAccessContainer::value_type;
    la::DenseMatrix<Scalar> x(nCount, numCoefficients);
    la::DenseVector<Scalar> y(nCount);    
    
    // fill Y matrix
    for (size_t i = 0; i < nCount; ++i)
        y[i] = useWeights ? yValues[i] * weights[i] : yValues[i];
    // fill X matrix (Vandermonde matrix)
    for (size_t nRow = 0; nRow < nCount; ++nRow) {
        Scalar nVal = 1.0f;
        for (size_t nCol = 0; nCol < numCoefficients; ++nCol) {
            x(nRow, nCol) = useWeights ? nVal * weights[nRow] : nVal;
            nVal *= xValues[nRow];
        }
    }
    
    auto xt = x.transpose();
    auto xtx = xt * x;
    auto rhs = xt * y;
    std::vector<Scalar> results(numCoefficients);
    la::VectorView<la::DenseVector<Scalar>> b(results.data(), results.size());
    b = xtx.fullPivLu().solve(rhs);
    return results;
}

/**
 * @brief Calculates the value of a polynomial of degree n evaluated at x.
 * The input argument coefficients is a vector of length n+1 whose elements
 * are the coefficients in incremental powers of the polynomial to be evaluated.
 * @tparam Scalar float type
 * @param coefficients polynomial coefficients generated by polyfit() function
 * @param xValue  X axis value
 * @return yValue Fitted Y value.
 */
template <typename Scalar, std::enable_if_t<std::is_floating_point_v<Scalar>, bool> = true>
inline Scalar PolyVal(const std::vector<Scalar> & coefficients, Scalar xVal)
{
    Scalar yVal = 0, xPowered = 1;
    for (size_t j = 0; j < coefficients.size(); ++j) {
        // multiply current x by coefficient
        yVal += coefficients[j] * xPowered;
        // power up the X
        xPowered *= xVal;
    }
    return yVal;
}

/**
 * @brief Calculates the value of a polynomial of degree n evaluated at x.
 * The input argument coefficients is a vector of length n+1 whose elements
 * are the coefficients in incremental powers of the polynomial to be evaluated.
 * @tparam RandomAccessContainer random access container concept
 * @param coefficients polynomial coefficients generated by polyfit() function
 * @param xValues  x axis values
 * @return std::vector<Scalar>  Fitted Y values.
 */
template <typename RandomAccessContainer, std::enable_if_t<std::is_floating_point_v<typename RandomAccessContainer::value_type>, bool> = true>
std::vector<typename RandomAccessContainer::value_type> PolyVal(const std::vector<typename RandomAccessContainer::value_type> & coefficients, const RandomAccessContainer & xValues)
{
    size_t nCount = xValues.size();
    using Scalar = typename RandomAccessContainer::value_type;
    std::vector<Scalar> yValues(nCount);
    for (size_t i = 0; i < nCount; ++i)
        yValues[i] = PolyVal(coefficients, xValues.at(i));
    return yValues;
}

} // namespace generic::math
